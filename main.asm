#include    <p16f688.inc> 
COUNTREG0	EQU		20h
COUNTREG1 	EQU		21h
COUNTREG2 	EQU		22h
PWM	 		EQU		23h
PWMC	 	EQU		24h
NAD			EQU		25h
ADH			EQU		26h


			ORG		0000h     		;Set start adress
			GOTO 	INIT			;Goto init pic routine

			ORG 	0004h			;Interrupt vector adress
			GOTO 	INT_HAND		;Goto interrupt handler
			

			;Init pic here
INIT:		BSF 	03,5			;Switch to bank 1.
			MOVLW	B'00110100'		;RA5, RA4 and RA2 are inputs porta.		
			MOVWF	TRISA			;Set input and outputs.	
			MOVLW	B'00100110'		;RC5, RC2 and RC1 are inputs.		
			MOVWF	TRISC			;Set input and outputs portc.
			MOVLW	B'01100111'		;Internet osc on 4MHz		
			MOVWF	OSCCON			;Set OSCCON.
			MOVLW	B'01100000'		;AN6 and AN5 are analog		
			MOVWF	ANSEL			;Set analog register
			MOVLW	B'01100000'		;Analog conversion clock is Fcy/64		
			MOVWF	ADCON1			;Set analog clock
	        BCF 	03,5			;Switch back to bank 0.
			MOVLW	B'00000001'		;Turn bluetooth module off	
			MOVWF	PORTA			;Set PORTA
			MOVLW	B'00001001'		;Heater is off and LED1 is on		
			MOVWF	PORTC			;Set PORTC	
			MOVLW	B'00100000'		;Put on serial module in async master 8 bits mode		
			MOVWF	TXSTA			;Set TXSTA
			MOVLW	B'10010000'		;Put on serial module in async master 8 bits mode		
			MOVWF	RCSTA			;Set RCSTA		
			MOVLW	B'00001000'		;Set baud register in 16 bits non inverting	
			MOVWF	BAUDCTL			;Set baud register
			MOVLW	018h			;Baudrate is 9600, so 4MHz/9600/16-1=25	
			MOVWF	SPBRG			;Set baudrate register
			MOVLW	B'10000001'		;Turn ADC on, data right justified	
			MOVWF	ADCON0			;Set ADC register
			;Pic init done here

			CALL 	DELAY1000
TURN_OFF:	BCF		PORTC, 0		;Turn the led off
			BCF		INTCON, T0IE	;Turn on timer 0 int
			BSF		PORTC, 3		;Turn the heater off
			BSF		PORTA, 0		;Turn BT off
			CAll	SWITCH_INT
			SLEEP					;Go to sleep

MEASURE:	BSF		PORTC, 1		;Turn the led on
			BCF		PORTA, 0		;Turn BT on
			CALL	SWITCH_INT		;Turn int on
			MOVLW	0C0h			;Preheat sensor for 4 seconds on 2volts using soft pwm
			MOVWF	PWM
			BSF		INTCON, T0IE	;Turn on timer 0 int
			BSF		INTCON, GIE		;Turn on global interrupts
			CALL 	DELAY1000
			BCF		PORTC, 0		;Turn the led off
			CALL 	DELAY1000
			BCF		PORTC, 1		;Turn the led on
			CALL 	DELAY1000
			BCF		PORTC, 0		;Turn the led off
			CALL 	DELAY1000
			BCF		PORTC, 1		;Turn the led on
			MOVLW	060h			;Heat sensor using soft pwm on 0.9 volts.
			MOVWF	PWM
			MOVLW	020h			;Make 20h measurements
			MOVWF	NAD
MAGAIN:		CALL	ADC				;Make measurment
			DECFSZ	NAD,1			;Check if we need to make one more
			GOTO	MAGAIN
			CALL 	BATTERY

FOREVER:	NOP
			GOTO	FOREVER


INT_HAND:	BTFSC	INTCON, INTF	;If int generated by pin RA2
			GOTO	INT_EXT			;Goto int routine for pin change
			;Else we have a timer interrupt for the PWM heater
			BCF		INTCON, T0IF	;Clear timer 0 int flag
			MOVF	PWMC,0			;Move pwm counter to w, preserving PWMC
			SUBWF	PWM,0			;Substract pwm counter from duty cycle reg
			BTFSC	STATUS, 0		;If =<0
			BSF		PORTC, 3		;Turn the heater off
			INCF	PWMC,1			;Increase pwm counter reg
			MOVLW	0FFh				;
			SUBWF	PWMC,0			;check if counted untill 0xff
			BTFSC	STATUS, 0		;If so
			BSF		PORTC, 1		;Turn the heater on
			CLRF	TMR0
			BSF		INTCON, T0IE	;Turn on timer 0 int	
			RETFIE	

INT_EXT:	CALL	DELAY1000		;Button is pressed, wait 1000ms
			BTFSS	PORTA, 3		;After 1 second the button is still pressed? Yes, then skip next instruction
			GOTO 	MEASURE
			GOTO 	TURN_OFF		;Long press means turn off
							

SWITCH_INT:	BCF		INTCON, GIE		;Turn off global interrupts
			BCF		INTCON, INTF	;Clear RA2 int flag
			BSF		INTCON, INTE	;Turn interrup on change of port RA2 on	
			BSF		INTCON, GIE		;Turn on global interrupts
			RETURN


DELAY1000:	MOVLW	05h				;Load 5 
        	MOVWF	COUNTREG2		;In count2
COUNT2:		MOVLW	0FFh			;Load FF 
        	MOVWF	COUNTREG1		;In count1
COUNT1:     MOVLW	0FFh			;Load FF
        	MOVWF	COUNTREG0		;In count0
COUNT0:     DECFSZ	COUNTREG0, 1	;count--
        	GOTO	COUNT0			;if!=0 count0
        	DECFSZ	COUNTREG1,1		;count1--
        	GOTO	COUNT1			;count again
        	DECFSZ	COUNTREG2,1		;count2--
        	GOTO	COUNT2				
			RETURN

ADC:		BCF		PORTC, 0		;Turn the led off
			MOVLW	B'10011001'		;Turn adc on, data right justified, measuring on AN6, sensor
			MOVWF	ADCON0			;Set ADC register
			CALL 	SMALLDELAY
			CALL	STARTADC
			BSF 	03,5			;Switch to bank 1
			MOVF	ADRESL,0		;Move ad result low to W
			BCF 	03,5			;Switch back to bank 0			
			CALL 	SEND
			MOVF	ADRESH,0		;Move ad result high to W
			CALL 	SEND
			BSF		PORTC, 0		;Turn the led on
			BCF		ADCON0, 0		;Turn off adc

			;No we wait some time before the next measurement
			MOVLW	0A0h			;Load FF 
        	MOVWF	COUNTREG1		;In count1
COUNT4:     MOVLW	0A0h			;Load FF
        	MOVWF	COUNTREG0		;In count0
COUNT5:     DECFSZ	COUNTREG0, 1	;count--
        	GOTO	COUNT5			;if!=0 count0
        	DECFSZ	COUNTREG1,1		;count1--
        	GOTO	COUNT4			;count again				
			RETURN

BATTERY:	MOVLW	B'10010101'		;Turn adc on, data right justified, measuring on AN5, Battery
			MOVWF	ADCON0			;Set ADC register
			CALL 	SMALLDELAY
			CALL	STARTADC
			BSF 	03,5			;Switch to bank 1
			MOVF	ADRESL,0		;Move ad result low to W
			BCF 	03,5			;Switch back to bank 0
			CALL 	SEND
			MOVF	ADRESH,0		;Move ad result high to W
			IORLW	0F0h				;First 4 bits high, to indicate this is the battery status
			CALL 	SEND
			BTFSS	ADRESH,1		;If battery less then half, turn off.
			GOTO	TURN_OFF
			RETURN

SMALLDELAY 	MOVLW	080h			;Load 50
        	MOVWF	COUNTREG0		;In count0
WAIT:		DECFSZ	COUNTREG0, 1	;count--
        	GOTO	WAIT			;if!=0 count0
			RETURN

STARTADC:	BSF		ADCON1, 1		;Start measurement
ADCBUSY:	BTFSC	ADCON1, 1		;Check if done with conversion
			GOTO	ADCBUSY			;If not, check again.
			RETURN

SEND:		BSF		RCSTA, 7		;Turn on serial port
			MOVWF	TXREG			;Put ad result in transmit register
FULL0:		BTFSS	TXSTA, 1		;Transmit buffer empty?
			GOTO 	FULL0			;If not check again
			BCF		RCSTA, 7		;Turn off serial port
			RETURN

			END